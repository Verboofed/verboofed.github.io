"use strict";
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const axios_1 = __importDefault(require("axios"));
const url_1 = require("url");
const https = __importStar(require("https"));
const axios_better_stacktrace_1 = __importDefault(require("axios-better-stacktrace"));
const Errors_1 = require("../../interfaces/Errors");
class HttpClient {
    constructor(config, privateConfig) {
        this.config = config;
        this.privateConfig = privateConfig;
        this.baseURL = 'https://api.spotify.com/v1';
        this.tokenURL = 'https://accounts.spotify.com/api/token';
        this.client = this.create({ resInterceptor: true });
    }
    /**
     * @param {string} slug
     * @param {string} query
     * @returns {string} Returns the full url.
     */
    getURL(slug, query) {
        const url = new url_1.URL(this.baseURL);
        url.pathname += slug;
        url.search = new url_1.URLSearchParams(query).toString();
        return url.toString();
    }
    /**
     * @description Get a refresh token.
     * @returns {string} Returns the refresh token.
     */
    async refreshToken(retryAmount = 0) {
        if (!this.config.clientCredentials.clientId ||
            !this.config.clientCredentials.clientSecret ||
            !this.config.refreshToken) {
            throw new Errors_1.AuthError('missing information needed to refresh token');
        }
        const res = await axios_1.default.post(this.tokenURL, new url_1.URLSearchParams({
            grant_type: 'refresh_token',
            refresh_token: this.config.refreshToken
        }), {
            headers: {
                authorization: `Basic ${Buffer.from(`${this.config.clientCredentials.clientId}:${this.config.clientCredentials.clientSecret}`).toString('base64')}`
            },
            validateStatus: () => true
        });
        // error handling
        if (res.status !== 200) {
            if (res.status === 400) {
                throw new Errors_1.AuthError(`refreshing token failed: bad request\n${JSON.stringify(res.data, null, ' ')}`);
            }
            if (retryAmount < 5) {
                console.log(`refreshing token failed (${res.status}). retrying... (${retryAmount + 1})`);
                await this.refreshToken(retryAmount + 1);
            }
            else if (res.status < 600 && res.status >= 500) {
                throw new Errors_1.AuthError(`refreshing token failed: server error (${res.status})`);
            }
            else {
                throw new Errors_1.AuthError(`refreshing token failed (${res.status})`);
            }
        }
        this.config.acccessToken = res.data.access_token; // save access token
        // save expire now
        this.privateConfig.tokenExpire = new Date(new Date().setSeconds(new Date().getSeconds() + 3600));
        return this.config.acccessToken; // return token
    }
    /**
     * Get authorization token with client credentials flow.
     */
    async getToken(retryAmount = 0) {
        const res = await axios_1.default.post(this.tokenURL, new url_1.URLSearchParams({
            grant_type: 'client_credentials'
        }), {
            headers: {
                authorization: `Basic ${Buffer.from(`${this.config.clientCredentials.clientId}:${this.config.clientCredentials.clientSecret}`).toString('base64')}`
            },
            validateStatus: () => true
        });
        // error handling
        if (res.status !== 200) {
            if (res.status === 400) {
                throw new Errors_1.AuthError(`getting token failed: bad request\n${JSON.stringify(res.data, null, ' ')}`);
            }
            if (retryAmount < 5) {
                console.log(`getting token failed (${res.status}). retrying... (${retryAmount + 1})`);
                await this.getToken(retryAmount + 1);
            }
            else if (res.status < 600 && res.status >= 500) {
                throw new Errors_1.AuthError(`getting token failed: server error (${res.status})`);
            }
            else {
                throw new Errors_1.AuthError(`getting token failed (${res.status})`);
            }
        }
        this.config.acccessToken = res.data.access_token;
        this.privateConfig.tokenExpire = new Date(new Date().setSeconds(new Date().getSeconds() + 3600));
        return this.config.acccessToken;
    }
    /**
     * @description Handles the auth tokens.
     * @returns {string} Returns a auth token.
     */
    async handleAuth() {
        if (this.config.acccessToken) {
            // check if token is expired
            if (new Date() >= this.privateConfig.tokenExpire) {
                this.config.acccessToken = undefined;
                return await this.handleAuth();
            }
            // return already defined access token
            return this.config.acccessToken;
        }
        // refresh token
        if (this.config?.clientCredentials?.clientId &&
            this.config?.clientCredentials?.clientSecret &&
            this.config?.refreshToken) {
            return await this.refreshToken(); // refresh token
        }
        // add credentials flow
        if (this.config?.clientCredentials?.clientId && this.config?.clientCredentials?.clientSecret) {
            return await this.getToken();
        }
        throw new Errors_1.AuthError('auth failed: missing information to handle auth');
    }
    /**
     * Sleep function.
     * @param {number} delay Delay in milliseconds.
     */
    sleep(delay) {
        return new Promise((resolve) => setTimeout(resolve, delay));
    }
    // create axios client, set interceptors, handle errors & auth
    create(options) {
        const config = {
            proxy: this.config.http?.proxy
        };
        if (this.config.http?.localAddress) {
            // TODO: https://github.com/axios/axios/issues/3876
            // @ts-expect-error `transport` is not included in axios types (see https://github.com/axios/axios/issues/3876)
            config.transport = {
                ...https,
                request: (options, callback) => https.request({
                    ...options,
                    localAddress: this.config.http?.localAddress,
                    family: this.config.http?.localAddress.includes(':') ? 6 : 4
                }, callback)
            };
        }
        const client = axios_1.default.create(config);
        axios_better_stacktrace_1.default(client);
        // request interceptor
        client.interceptors.request.use(async (config) => {
            // add authorization, content
            config.headers = {
                Authorization: `Bearer ${await this.handleAuth()}`,
                // 'Content-Type': 'application/json',
                // Accept: 'application/json',
                'User-Agent': this.config.http?.userAgent || `spotify.js https://github.com/statsfm/spotify.js`,
                ...config.headers
            };
            return config;
        });
        if (options.resInterceptor || options.resInterceptor === undefined) {
            // response interceptor
            client.interceptors.response.use((config) => config, 
            // error handler
            async (err) => {
                let res = err.response;
                if (res?.status) {
                    // throw error if bad request
                    if (res.status === 400) {
                        throw new Errors_1.BadRequestError(`bad request\n${JSON.stringify(err.response.data, null, ' ')}`, err.stack);
                    }
                    // throw error if forbideden
                    if (res.status === 403) {
                        throw new Errors_1.ForbiddenError(`forbidden, are you sure you have the right scopes?\n${JSON.stringify(res.data, null, ' ')}`, err.stack);
                    }
                    // throw error if 404
                    if (res.status === 404) {
                        throw new Errors_1.NotFoundError(`not found (${res.config.url})`, err.stack);
                    }
                    if (res.status === 401) {
                        throw new Errors_1.AuthError('unauthorized', err.stack);
                        //   await this.handleAuth();
                        //   const res = await client.request(err.config);
                        //   return res;
                    }
                    // 5xx
                    if (res.status.toString().startsWith('5')) {
                        if (this.config.retry5xx || this.config.retry5xx === undefined) {
                            // set default
                            if (!this.config.retry5xxAmount)
                                this.config.retry5xxAmount = 3;
                            // create new axios client without interceptors
                            const nClient = this.create({ resInterceptor: false });
                            // retry x times
                            for (let i = 0; i < this.config.retry5xxAmount; i++) {
                                console.log(`${res.status} error, retrying... (${i + 1}/${this.config.retry5xxAmount})`);
                                // timeout one second
                                // eslint-disable-next-line no-await-in-loop
                                await this.sleep(1 * 1000); // wait for retry time
                                // disable error checking
                                // err.config.validateStatus = (): boolean => true;
                                try {
                                    // retry request
                                    // eslint-disable-next-line no-await-in-loop
                                    const nRes = await nClient.request(err.config);
                                    // starts with 200, successful
                                    if (nRes.status.toString().startsWith('2')) {
                                        return nRes;
                                    }
                                }
                                catch (err) {
                                    if (i === this.config.retry5xxAmount - 1) {
                                        throw new Error(`${res.status} error, retried ${this.config.retry5xxAmount} times\n${err.stack}`);
                                    }
                                }
                            }
                        }
                    }
                    // if (res.status === 500) {
                    //   throw new InternalServerError('internal server error', err.stack);
                    // }
                    if (res.status === 429) {
                        if (this.config.retry || this.config.retry === undefined) {
                            const retry = res.headers[`retry-after`]; // get retry time
                            // log ratelimit (if enabled)
                            if (this.config.logRetry || this.config.logRetry === undefined) {
                                // eslint-disable-next-line no-console
                                console.error(`hit ratelimit, retrying in ${'retry'} second(s), client id: ${this.config?.clientCredentials?.clientId}, localAddress: ${this.config.http.localAddress}, path: ${err.request.path}`);
                            }
                            await this.sleep(retry * 1000); // wait for retry time
                            res = await client.request(err.config); // retry request
                        }
                        else {
                            throw new Errors_1.RatelimitError('hit ratelimit', err.stack);
                        }
                        return res;
                    }
                }
                throw err;
            });
        }
        return client;
    }
    /**
     * @param {string} slug The slug to get.
     * @param {{query?: Record<string, string> & AxiosRequestConfig}} options Options.
     * @returns {Promise<AxiosResponse>} Returns a promise with the response.
     */
    async get(slug, options) {
        return await this.client.get(this.getURL(slug, options?.query), options);
    }
    /**
     * @param {string} slug The slug to post.
     * @param {any} data Body data.
     * @param {{Record<string, string> & RequestInit}} config Config.
     * @returns {Promise<Response>} Returns a promise with the response.
     */
    async post(slug, data, config) {
        return await this.client.post(this.getURL(slug, config?.query), data, config);
    }
    /**
     * @param {string} slug The slug to put.
     * @param {any} data Body data.
     * @param {{Record<string, string> & RequestInit}} config Config.
     * @returns {Promise<Response>} Returns a promise with the response.
     */
    async put(slug, data, config) {
        return await this.client.put(this.getURL(slug, config?.query), data, config);
    }
    /**
     * @param {string} slug The slug to delete.
     * @param {any} data Body data.
     * @param {{Record<string, string> & RequestInit}} options Options.
     * @returns {Promise<Response>} Returns a promise with the response.
     */
    async delete(slug, data, options) {
        return await this.client.delete(this.getURL(slug, options?.query), {
            ...options,
            data
        });
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpManager.js.map